#!/usr/bin/env python3
import sys
import math
import numpy as np
from rclpy import init, spin, shutdown
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from ackermann_msgs.msg import AckermannDriveStamped

# PID CONTROL PARAMS
kp = -15
kd = 5
ki = 0
servo_offset = 0.0
prev_error = 0.0 
error = 0.0
integral = 0.0

# WALL FOLLOW PARAMS
ANGLE_RANGE = 270  # Hokuyo 10LX has 270 degrees scan
DESIRED_DISTANCE_RIGHT = 0.9  # meters
DESIRED_DISTANCE_LEFT = 0.55
VELOCITY = 2.00  # meters per second
CAR_LENGTH = 0.50  # Traxxas Rally is 20 inches or 0.5 meters

class WallFollow(Node):
    """ Implement Wall Following on the car """
    def __init__(self):
        super().__init__('wall_follow_node')
        # Topics & Subs, Pubs
        self.lidar_sub = self.create_subscription(LaserScan, '/scan', self.lidar_callback, 10)
        self.drive_pub = self.create_publisher(AckermannDriveStamped, '/drive', 10)

    def get_range(self, data, angle):
        """ Get range data for a specified angle """
        ranges = np.array(data.ranges)
        angle_incr = data.angle_increment
        desired_idx = int((np.radians(angle) - data.angle_min) / angle_incr)
        if np.isfinite(ranges[desired_idx]):
            return ranges[desired_idx]
        else:
            return None

    def pid_control(self, error):
        global integral, prev_error, kp, ki, kd
        deriv_error = error - prev_error
        prev_error = error
        
        integral += error
        angle = np.radians(kp * error + kd * deriv_error + ki * integral)
        velocity = self.calc_speed(angle)
        self.get_logger().info(f"Error: {error}, Angle: {np.degrees(angle)}")

        drive_msg = AckermannDriveStamped()
        drive_msg.header.stamp = self.get_clock().now().to_msg()
        drive_msg.header.frame_id = "laser"
        drive_msg.drive.steering_angle = angle
        drive_msg.drive.speed = velocity
        self.drive_pub.publish(drive_msg)

    def calc_speed(self, angle):
        angle = np.abs(np.degrees(angle))
        if angle < 10:
            speed = 1.5
        elif angle < 20:
            speed = 1.0
        else:
            speed = 0.5
        return speed

    def follow_left(self, data):
        zero_angle = 90
        b = self.get_range(data, zero_angle)
        
        theta = 40
        a = self.get_range(data, zero_angle - theta)
        theta = np.radians(theta)
        if b is not None and a is not None:
            alpha = np.arctan2(a * np.cos(theta) - b, a * np.sin(theta))
            Dleft = b * np.cos(alpha)

            D_left_lookahead = Dleft + CAR_LENGTH * np.sin(alpha)

            error = DESIRED_DISTANCE_LEFT - D_left_lookahead
            return error
        else:
            return None

    def lidar_callback(self, data):
        """ Lidar callback for processing data """
        error = self.follow_left(data)
        if error is not None:
            self.pid_control(error)

def main(args=None):
    init(args=args)
    wall_follow = WallFollow()
    spin(wall_follow)
    wall_follow.destroy_node()
    shutdown()

if __name__ == '__main__':
    main()
